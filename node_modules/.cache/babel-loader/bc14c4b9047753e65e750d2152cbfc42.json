{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nexports.default = function (Base) {\n  return function (_Base) {\n    _inherits(_class, _Base);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: 'getResolvedState',\n      value: function getResolvedState(props, state) {\n        var resolvedState = _extends({}, _utils2.default.compactObject(this.state), _utils2.default.compactObject(this.props), _utils2.default.compactObject(state), _utils2.default.compactObject(props));\n\n        return resolvedState;\n      }\n    }, {\n      key: 'getDataModel',\n      value: function getDataModel(newState) {\n        var _this2 = this;\n\n        var columns = newState.columns,\n            _newState$pivotBy = newState.pivotBy,\n            pivotBy = _newState$pivotBy === undefined ? [] : _newState$pivotBy,\n            data = newState.data,\n            pivotIDKey = newState.pivotIDKey,\n            pivotValKey = newState.pivotValKey,\n            subRowsKey = newState.subRowsKey,\n            aggregatedKey = newState.aggregatedKey,\n            nestingLevelKey = newState.nestingLevelKey,\n            originalKey = newState.originalKey,\n            indexKey = newState.indexKey,\n            groupedByPivotKey = newState.groupedByPivotKey,\n            SubComponent = newState.SubComponent; // Determine Header Groups\n\n        var hasHeaderGroups = false;\n        columns.forEach(function (column) {\n          if (column.columns) {\n            hasHeaderGroups = true;\n          }\n        });\n        var columnsWithExpander = [].concat(_toConsumableArray(columns));\n        var expanderColumn = columns.find(function (col) {\n          return col.expander || col.columns && col.columns.some(function (col2) {\n            return col2.expander;\n          });\n        }); // The actual expander might be in the columns field of a group column\n\n        if (expanderColumn && !expanderColumn.expander) {\n          expanderColumn = expanderColumn.columns.find(function (col) {\n            return col.expander;\n          });\n        } // If we have SubComponent's we need to make sure we have an expander column\n\n\n        if (SubComponent && !expanderColumn) {\n          expanderColumn = {\n            expander: true\n          };\n          columnsWithExpander = [expanderColumn].concat(_toConsumableArray(columnsWithExpander));\n        }\n\n        var makeDecoratedColumn = function makeDecoratedColumn(column, parentColumn) {\n          var dcol = void 0;\n\n          if (column.expander) {\n            dcol = _extends({}, _this2.props.column, _this2.props.expanderDefaults, column);\n          } else {\n            dcol = _extends({}, _this2.props.column, column);\n          } // Ensure minWidth is not greater than maxWidth if set\n\n\n          if (dcol.maxWidth < dcol.minWidth) {\n            dcol.minWidth = dcol.maxWidth;\n          }\n\n          if (parentColumn) {\n            dcol.parentColumn = parentColumn;\n          } // First check for string accessor\n\n\n          if (typeof dcol.accessor === 'string') {\n            var _ret = function () {\n              dcol.id = dcol.id || dcol.accessor;\n              var accessorString = dcol.accessor;\n\n              dcol.accessor = function (row) {\n                return _utils2.default.get(row, accessorString);\n              };\n\n              return {\n                v: dcol\n              };\n            }();\n\n            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n          } // Fall back to functional accessor (but require an ID)\n\n\n          if (dcol.accessor && !dcol.id) {\n            console.warn(dcol);\n            throw new Error('A column id is required if using a non-string accessor for column above.');\n          } // Fall back to an undefined accessor\n\n\n          if (!dcol.accessor) {\n            dcol.accessor = function (d) {\n              return undefined;\n            };\n          }\n\n          return dcol;\n        }; // Decorate the columns\n\n\n        var decorateAndAddToAll = function decorateAndAddToAll(column, parentColumn) {\n          var decoratedColumn = makeDecoratedColumn(column, parentColumn);\n          allDecoratedColumns.push(decoratedColumn);\n          return decoratedColumn;\n        };\n\n        var allDecoratedColumns = [];\n        var decoratedColumns = columnsWithExpander.map(function (column, i) {\n          if (column.columns) {\n            return _extends({}, column, {\n              columns: column.columns.map(function (d) {\n                return decorateAndAddToAll(d, column);\n              })\n            });\n          } else {\n            return decorateAndAddToAll(column);\n          }\n        }); // Build the visible columns, headers and flat column list\n\n        var visibleColumns = decoratedColumns.slice();\n        var allVisibleColumns = [];\n        visibleColumns = visibleColumns.map(function (column, i) {\n          if (column.columns) {\n            var visibleSubColumns = column.columns.filter(function (d) {\n              return pivotBy.indexOf(d.id) > -1 ? false : _utils2.default.getFirstDefined(d.show, true);\n            });\n            return _extends({}, column, {\n              columns: visibleSubColumns\n            });\n          }\n\n          return column;\n        });\n        visibleColumns = visibleColumns.filter(function (column) {\n          return column.columns ? column.columns.length : pivotBy.indexOf(column.id) > -1 ? false : _utils2.default.getFirstDefined(column.show, true);\n        }); // Find any custom pivot location\n\n        var pivotIndex = visibleColumns.findIndex(function (col) {\n          return col.pivot;\n        }); // Handle Pivot Columns\n\n        if (pivotBy.length) {\n          (function () {\n            // Retrieve the pivot columns in the correct pivot order\n            var pivotColumns = [];\n            pivotBy.forEach(function (pivotID) {\n              var found = allDecoratedColumns.find(function (d) {\n                return d.id === pivotID;\n              });\n\n              if (found) {\n                pivotColumns.push(found);\n              }\n            });\n            var PivotParentColumn = pivotColumns.reduce(function (prev, current) {\n              return prev && prev === current.parentColumn && current.parentColumn;\n            }, pivotColumns[0].parentColumn);\n            var PivotGroupHeader = hasHeaderGroups && PivotParentColumn.Header;\n\n            PivotGroupHeader = PivotGroupHeader || function () {\n              return _react2.default.createElement('strong', null, 'Pivoted');\n            };\n\n            var pivotColumnGroup = {\n              Header: PivotGroupHeader,\n              columns: pivotColumns.map(function (col) {\n                return _extends({}, _this2.props.pivotDefaults, col, {\n                  pivoted: true\n                });\n              })\n            }; // Place the pivotColumns back into the visibleColumns\n\n            if (pivotIndex >= 0) {\n              pivotColumnGroup = _extends({}, visibleColumns[pivotIndex], pivotColumnGroup);\n              visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);\n            } else {\n              visibleColumns.unshift(pivotColumnGroup);\n            }\n          })();\n        } // Build Header Groups\n\n\n        var headerGroups = [];\n        var currentSpan = []; // A convenience function to add a header and reset the currentSpan\n\n        var addHeader = function addHeader(columns, column) {\n          headerGroups.push(_extends({}, _this2.props.column, column, {\n            columns: columns\n          }));\n          currentSpan = [];\n        }; // Build flast list of allVisibleColumns and HeaderGroups\n\n\n        visibleColumns.forEach(function (column, i) {\n          if (column.columns) {\n            allVisibleColumns = allVisibleColumns.concat(column.columns);\n\n            if (currentSpan.length > 0) {\n              addHeader(currentSpan);\n            }\n\n            addHeader(column.columns, column);\n            return;\n          }\n\n          allVisibleColumns.push(column);\n          currentSpan.push(column);\n        });\n\n        if (hasHeaderGroups && currentSpan.length > 0) {\n          addHeader(currentSpan);\n        } // Access the data\n\n\n        var accessRow = function accessRow(d, i) {\n          var _row;\n\n          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var row = (_row = {}, _defineProperty(_row, originalKey, d), _defineProperty(_row, indexKey, i), _defineProperty(_row, subRowsKey, d[subRowsKey]), _defineProperty(_row, nestingLevelKey, level), _row);\n          allDecoratedColumns.forEach(function (column) {\n            if (column.expander) return;\n            row[column.id] = column.accessor(d);\n          });\n\n          if (row[subRowsKey]) {\n            row[subRowsKey] = row[subRowsKey].map(function (d, i) {\n              return accessRow(d, i, level + 1);\n            });\n          }\n\n          return row;\n        };\n\n        var resolvedData = data.map(function (d, i) {\n          return accessRow(d, i);\n        }); // If pivoting, recursively group the data\n\n        var aggregate = function aggregate(rows) {\n          var aggregationValues = {};\n          aggregatingColumns.forEach(function (column) {\n            var values = rows.map(function (d) {\n              return d[column.id];\n            });\n            aggregationValues[column.id] = column.aggregate(values, rows);\n          });\n          return aggregationValues;\n        }; // TODO: Make it possible to fabricate nested rows without pivoting\n\n\n        var aggregatingColumns = allVisibleColumns.filter(function (d) {\n          return !d.expander && d.aggregate;\n        });\n\n        if (pivotBy.length) {\n          (function () {\n            var groupRecursively = function groupRecursively(rows, keys) {\n              var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // This is the last level, just return the rows\n\n              if (i === keys.length) {\n                return rows;\n              } // Group the rows together for this level\n\n\n              var groupedRows = Object.entries(_utils2.default.groupBy(rows, keys[i])).map(function (_ref) {\n                var _ref3;\n\n                var _ref2 = _slicedToArray(_ref, 2),\n                    key = _ref2[0],\n                    value = _ref2[1];\n\n                return _ref3 = {}, _defineProperty(_ref3, pivotIDKey, keys[i]), _defineProperty(_ref3, pivotValKey, key), _defineProperty(_ref3, keys[i], key), _defineProperty(_ref3, subRowsKey, value), _defineProperty(_ref3, nestingLevelKey, i), _defineProperty(_ref3, groupedByPivotKey, true), _ref3;\n              }); // Recurse into the subRows\n\n              groupedRows = groupedRows.map(function (rowGroup) {\n                var _extends2;\n\n                var subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);\n                return _extends({}, rowGroup, (_extends2 = {}, _defineProperty(_extends2, subRowsKey, subRows), _defineProperty(_extends2, aggregatedKey, true), _extends2), aggregate(subRows));\n              });\n              return groupedRows;\n            };\n\n            resolvedData = groupRecursively(resolvedData, pivotBy);\n          })();\n        }\n\n        return _extends({}, newState, {\n          resolvedData: resolvedData,\n          allVisibleColumns: allVisibleColumns,\n          headerGroups: headerGroups,\n          allDecoratedColumns: allDecoratedColumns,\n          hasHeaderGroups: hasHeaderGroups\n        });\n      }\n    }, {\n      key: 'getSortedData',\n      value: function getSortedData(resolvedState) {\n        var manual = resolvedState.manual,\n            sorted = resolvedState.sorted,\n            filtered = resolvedState.filtered,\n            defaultFilterMethod = resolvedState.defaultFilterMethod,\n            resolvedData = resolvedState.resolvedData,\n            allVisibleColumns = resolvedState.allVisibleColumns,\n            allDecoratedColumns = resolvedState.allDecoratedColumns;\n        var sortMethodsByColumnID = {};\n        allDecoratedColumns.filter(function (col) {\n          return col.sortMethod;\n        }).forEach(function (col) {\n          sortMethodsByColumnID[col.id] = col.sortMethod;\n        }); // Resolve the data from either manual data or sorted data\n\n        return {\n          sortedData: manual ? resolvedData : this.sortData(this.filterData(resolvedData, filtered, defaultFilterMethod, allVisibleColumns), sorted, sortMethodsByColumnID)\n        };\n      }\n    }, {\n      key: 'fireFetchData',\n      value: function fireFetchData() {\n        this.props.onFetchData(this.getResolvedState(), this);\n      }\n    }, {\n      key: 'getPropOrState',\n      value: function getPropOrState(key) {\n        return _utils2.default.getFirstDefined(this.props[key], this.state[key]);\n      }\n    }, {\n      key: 'getStateOrProp',\n      value: function getStateOrProp(key) {\n        return _utils2.default.getFirstDefined(this.state[key], this.props[key]);\n      }\n    }, {\n      key: 'filterData',\n      value: function filterData(data, filtered, defaultFilterMethod, allVisibleColumns) {\n        var _this3 = this;\n\n        var filteredData = data;\n\n        if (filtered.length) {\n          filteredData = filtered.reduce(function (filteredSoFar, nextFilter) {\n            var column = allVisibleColumns.find(function (x) {\n              return x.id === nextFilter.id;\n            }); // Don't filter hidden columns or columns that have had their filters disabled\n\n            if (!column || column.filterable === false) {\n              return filteredSoFar;\n            }\n\n            var filterMethod = column.filterMethod || defaultFilterMethod; // If 'filterAll' is set to true, pass the entire dataset to the filter method\n\n            if (column.filterAll) {\n              return filterMethod(nextFilter, filteredSoFar, column);\n            } else {\n              return filteredSoFar.filter(function (row) {\n                return filterMethod(nextFilter, row, column);\n              });\n            }\n          }, filteredData); // Apply the filter to the subrows if we are pivoting, and then\n          // filter any rows without subcolumns because it would be strange to show\n\n          filteredData = filteredData.map(function (row) {\n            if (!row[_this3.props.subRowsKey]) {\n              return row;\n            }\n\n            return _extends({}, row, _defineProperty({}, _this3.props.subRowsKey, _this3.filterData(row[_this3.props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns)));\n          }).filter(function (row) {\n            if (!row[_this3.props.subRowsKey]) {\n              return true;\n            }\n\n            return row[_this3.props.subRowsKey].length > 0;\n          });\n        }\n\n        return filteredData;\n      }\n    }, {\n      key: 'sortData',\n      value: function sortData(data, sorted) {\n        var _this4 = this;\n\n        var sortMethodsByColumnID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!sorted.length) {\n          return data;\n        }\n\n        var sortedData = (this.props.orderByMethod || _utils2.default.orderBy)(data, sorted.map(function (sort) {\n          // Support custom sorting methods for each column\n          if (sortMethodsByColumnID[sort.id]) {\n            return function (a, b) {\n              return sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);\n            };\n          }\n\n          return function (a, b) {\n            return _this4.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);\n          };\n        }), sorted.map(function (d) {\n          return !d.desc;\n        }), this.props.indexKey);\n\n        sortedData.forEach(function (row) {\n          if (!row[_this4.props.subRowsKey]) {\n            return;\n          }\n\n          row[_this4.props.subRowsKey] = _this4.sortData(row[_this4.props.subRowsKey], sorted, sortMethodsByColumnID);\n        });\n        return sortedData;\n      }\n    }, {\n      key: 'getMinRows',\n      value: function getMinRows() {\n        return _utils2.default.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'));\n      } // User actions\n\n    }, {\n      key: 'onPageChange',\n      value: function onPageChange(page) {\n        var _props = this.props,\n            onPageChange = _props.onPageChange,\n            collapseOnPageChange = _props.collapseOnPageChange;\n        var newState = {\n          page: page\n        };\n\n        if (collapseOnPageChange) {\n          newState.expanded = {};\n        }\n\n        this.setStateWithData(newState, function () {\n          onPageChange && onPageChange(page);\n        });\n      }\n    }, {\n      key: 'onPageSizeChange',\n      value: function onPageSizeChange(newPageSize) {\n        var onPageSizeChange = this.props.onPageSizeChange;\n\n        var _getResolvedState = this.getResolvedState(),\n            pageSize = _getResolvedState.pageSize,\n            page = _getResolvedState.page; // Normalize the page to display\n\n\n        var currentRow = pageSize * page;\n        var newPage = Math.floor(currentRow / newPageSize);\n        this.setStateWithData({\n          pageSize: newPageSize,\n          page: newPage\n        }, function () {\n          onPageSizeChange && onPageSizeChange(newPageSize, newPage);\n        });\n      }\n    }, {\n      key: 'sortColumn',\n      value: function sortColumn(column, additive) {\n        var _getResolvedState2 = this.getResolvedState(),\n            sorted = _getResolvedState2.sorted,\n            skipNextSort = _getResolvedState2.skipNextSort,\n            defaultSortDesc = _getResolvedState2.defaultSortDesc;\n\n        var firstSortDirection = column.hasOwnProperty('defaultSortDesc') ? column.defaultSortDesc : defaultSortDesc;\n        var secondSortDirection = !firstSortDirection; // we can't stop event propagation from the column resize move handlers\n        // attached to the document because of react's synthetic events\n        // so we have to prevent the sort function from actually sorting\n        // if we click on the column resize element within a header.\n\n        if (skipNextSort) {\n          this.setStateWithData({\n            skipNextSort: false\n          });\n          return;\n        }\n\n        var onSortedChange = this.props.onSortedChange;\n\n        var newSorted = _utils2.default.clone(sorted || []).map(function (d) {\n          d.desc = _utils2.default.isSortingDesc(d);\n          return d;\n        });\n\n        if (!_utils2.default.isArray(column)) {\n          // Single-Sort\n          var existingIndex = newSorted.findIndex(function (d) {\n            return d.id === column.id;\n          });\n\n          if (existingIndex > -1) {\n            var existing = newSorted[existingIndex];\n\n            if (existing.desc === secondSortDirection) {\n              if (additive) {\n                newSorted.splice(existingIndex, 1);\n              } else {\n                existing.desc = firstSortDirection;\n                newSorted = [existing];\n              }\n            } else {\n              existing.desc = secondSortDirection;\n\n              if (!additive) {\n                newSorted = [existing];\n              }\n            }\n          } else {\n            if (additive) {\n              newSorted.push({\n                id: column.id,\n                desc: firstSortDirection\n              });\n            } else {\n              newSorted = [{\n                id: column.id,\n                desc: firstSortDirection\n              }];\n            }\n          }\n        } else {\n          (function () {\n            // Multi-Sort\n            var existingIndex = newSorted.findIndex(function (d) {\n              return d.id === column[0].id;\n            }); // Existing Sorted Column\n\n            if (existingIndex > -1) {\n              var _existing = newSorted[existingIndex];\n\n              if (_existing.desc === secondSortDirection) {\n                if (additive) {\n                  newSorted.splice(existingIndex, column.length);\n                } else {\n                  column.forEach(function (d, i) {\n                    newSorted[existingIndex + i].desc = firstSortDirection;\n                  });\n                }\n              } else {\n                column.forEach(function (d, i) {\n                  newSorted[existingIndex + i].desc = secondSortDirection;\n                });\n              }\n\n              if (!additive) {\n                newSorted = newSorted.slice(existingIndex, column.length);\n              }\n            } else {\n              // New Sort Column\n              if (additive) {\n                newSorted = newSorted.concat(column.map(function (d) {\n                  return {\n                    id: d.id,\n                    desc: firstSortDirection\n                  };\n                }));\n              } else {\n                newSorted = column.map(function (d) {\n                  return {\n                    id: d.id,\n                    desc: firstSortDirection\n                  };\n                });\n              }\n            }\n          })();\n        }\n\n        this.setStateWithData({\n          page: !sorted.length && newSorted.length || !additive ? 0 : this.state.page,\n          sorted: newSorted\n        }, function () {\n          onSortedChange && onSortedChange(newSorted, column, additive);\n        });\n      }\n    }, {\n      key: 'filterColumn',\n      value: function filterColumn(column, value) {\n        var _getResolvedState3 = this.getResolvedState(),\n            filtered = _getResolvedState3.filtered;\n\n        var onFilteredChange = this.props.onFilteredChange; // Remove old filter first if it exists\n\n        var newFiltering = (filtered || []).filter(function (x) {\n          if (x.id !== column.id) {\n            return true;\n          }\n        });\n\n        if (value !== '') {\n          newFiltering.push({\n            id: column.id,\n            value: value\n          });\n        }\n\n        this.setStateWithData({\n          filtered: newFiltering\n        }, function () {\n          onFilteredChange && onFilteredChange(newFiltering, column, value);\n        });\n      }\n    }, {\n      key: 'resizeColumnStart',\n      value: function resizeColumnStart(event, column, isTouch) {\n        var _this5 = this;\n\n        event.stopPropagation();\n        var parentWidth = event.target.parentElement.getBoundingClientRect().width;\n        var pageX = void 0;\n\n        if (isTouch) {\n          pageX = event.changedTouches[0].pageX;\n        } else {\n          pageX = event.pageX;\n        }\n\n        this.trapEvents = true;\n        this.setStateWithData({\n          currentlyResizing: {\n            id: column.id,\n            startX: pageX,\n            parentWidth: parentWidth\n          }\n        }, function () {\n          if (isTouch) {\n            document.addEventListener('touchmove', _this5.resizeColumnMoving);\n            document.addEventListener('touchcancel', _this5.resizeColumnEnd);\n            document.addEventListener('touchend', _this5.resizeColumnEnd);\n          } else {\n            document.addEventListener('mousemove', _this5.resizeColumnMoving);\n            document.addEventListener('mouseup', _this5.resizeColumnEnd);\n            document.addEventListener('mouseleave', _this5.resizeColumnEnd);\n          }\n        });\n      }\n    }, {\n      key: 'resizeColumnMoving',\n      value: function resizeColumnMoving(event) {\n        event.stopPropagation();\n        var onResizedChange = this.props.onResizedChange;\n\n        var _getResolvedState4 = this.getResolvedState(),\n            resized = _getResolvedState4.resized,\n            currentlyResizing = _getResolvedState4.currentlyResizing; // Delete old value\n\n\n        var newResized = resized.filter(function (x) {\n          return x.id !== currentlyResizing.id;\n        });\n        var pageX = void 0;\n\n        if (event.type === 'touchmove') {\n          pageX = event.changedTouches[0].pageX;\n        } else if (event.type === 'mousemove') {\n          pageX = event.pageX;\n        } // Set the min size to 10 to account for margin and border or else the group headers don't line up correctly\n\n\n        var newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, 11);\n        newResized.push({\n          id: currentlyResizing.id,\n          value: newWidth\n        });\n        this.setStateWithData({\n          resized: newResized\n        }, function () {\n          onResizedChange && onResizedChange(newResized, event);\n        });\n      }\n    }, {\n      key: 'resizeColumnEnd',\n      value: function resizeColumnEnd(event) {\n        event.stopPropagation();\n        var isTouch = event.type === 'touchend' || event.type === 'touchcancel';\n\n        if (isTouch) {\n          document.removeEventListener('touchmove', this.resizeColumnMoving);\n          document.removeEventListener('touchcancel', this.resizeColumnEnd);\n          document.removeEventListener('touchend', this.resizeColumnEnd);\n        } // If its a touch event clear the mouse one's as well because sometimes\n        // the mouseDown event gets called as well, but the mouseUp event doesn't\n\n\n        document.removeEventListener('mousemove', this.resizeColumnMoving);\n        document.removeEventListener('mouseup', this.resizeColumnEnd);\n        document.removeEventListener('mouseleave', this.resizeColumnEnd); // The touch events don't propagate up to the sorting's onMouseDown event so\n        // no need to prevent it from happening or else the first click after a touch\n        // event resize will not sort the column.\n\n        if (!isTouch) {\n          this.setStateWithData({\n            skipNextSort: true,\n            currentlyResizing: false\n          });\n        }\n      }\n    }]);\n\n    return _class;\n  }(Base);\n};","map":{"version":3,"sources":["../src/methods.js"],"names":["resolvedState","columns","pivotBy","data","pivotIDKey","pivotValKey","subRowsKey","aggregatedKey","nestingLevelKey","originalKey","indexKey","groupedByPivotKey","SubComponent","newState","hasHeaderGroups","column","columnsWithExpander","expanderColumn","col","col2","expander","makeDecoratedColumn","dcol","accessorString","console","decorateAndAddToAll","decoratedColumn","allDecoratedColumns","decoratedColumns","visibleColumns","allVisibleColumns","visibleSubColumns","d","pivotIndex","pivotColumns","found","PivotParentColumn","prev","current","PivotGroupHeader","pivotColumnGroup","Header","pivoted","headerGroups","currentSpan","addHeader","accessRow","level","row","resolvedData","aggregate","aggregationValues","aggregatingColumns","values","groupRecursively","i","keys","groupedRows","key","value","subRows","rowGroup","manual","sorted","filtered","defaultFilterMethod","sortMethodsByColumnID","sortedData","filteredData","x","nextFilter","filterMethod","sort","a","b","onPageChange","collapseOnPageChange","page","onPageSizeChange","pageSize","currentRow","newPage","Math","skipNextSort","defaultSortDesc","firstSortDirection","secondSortDirection","onSortedChange","newSorted","existingIndex","existing","id","desc","onFilteredChange","newFiltering","event","parentWidth","pageX","currentlyResizing","startX","document","onResizedChange","resized","newResized","newWidth","isTouch"],"mappings":"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","sourcesContent":["import React from 'react'\nimport _ from './utils'\n\nexport default Base =>\n  class extends Base {\n    getResolvedState (props, state) {\n      const resolvedState = {\n        ..._.compactObject(this.state),\n        ..._.compactObject(this.props),\n        ..._.compactObject(state),\n        ..._.compactObject(props),\n      }\n      return resolvedState\n    }\n\n    getDataModel (newState) {\n      const {\n        columns,\n        pivotBy = [],\n        data,\n        pivotIDKey,\n        pivotValKey,\n        subRowsKey,\n        aggregatedKey,\n        nestingLevelKey,\n        originalKey,\n        indexKey,\n        groupedByPivotKey,\n        SubComponent,\n      } = newState\n\n      // Determine Header Groups\n      let hasHeaderGroups = false\n      columns.forEach(column => {\n        if (column.columns) {\n          hasHeaderGroups = true\n        }\n      })\n\n      let columnsWithExpander = [...columns]\n\n      let expanderColumn = columns.find(\n        col =>\n          col.expander ||\n          (col.columns && col.columns.some(col2 => col2.expander))\n      )\n      // The actual expander might be in the columns field of a group column\n      if (expanderColumn && !expanderColumn.expander) {\n        expanderColumn = expanderColumn.columns.find(col => col.expander)\n      }\n\n      // If we have SubComponent's we need to make sure we have an expander column\n      if (SubComponent && !expanderColumn) {\n        expanderColumn = { expander: true }\n        columnsWithExpander = [expanderColumn, ...columnsWithExpander]\n      }\n\n      const makeDecoratedColumn = (column, parentColumn) => {\n        let dcol\n        if (column.expander) {\n          dcol = {\n            ...this.props.column,\n            ...this.props.expanderDefaults,\n            ...column,\n          }\n        } else {\n          dcol = {\n            ...this.props.column,\n            ...column,\n          }\n        }\n\n        // Ensure minWidth is not greater than maxWidth if set\n        if (dcol.maxWidth < dcol.minWidth) {\n          dcol.minWidth = dcol.maxWidth\n        }\n\n        if (parentColumn) {\n          dcol.parentColumn = parentColumn\n        }\n\n        // First check for string accessor\n        if (typeof dcol.accessor === 'string') {\n          dcol.id = dcol.id || dcol.accessor\n          const accessorString = dcol.accessor\n          dcol.accessor = row => _.get(row, accessorString)\n          return dcol\n        }\n\n        // Fall back to functional accessor (but require an ID)\n        if (dcol.accessor && !dcol.id) {\n          console.warn(dcol)\n          throw new Error(\n            'A column id is required if using a non-string accessor for column above.'\n          )\n        }\n\n        // Fall back to an undefined accessor\n        if (!dcol.accessor) {\n          dcol.accessor = d => undefined\n        }\n\n        return dcol\n      }\n\n      // Decorate the columns\n      const decorateAndAddToAll = (column, parentColumn) => {\n        const decoratedColumn = makeDecoratedColumn(column, parentColumn)\n        allDecoratedColumns.push(decoratedColumn)\n        return decoratedColumn\n      }\n      const allDecoratedColumns = []\n      const decoratedColumns = columnsWithExpander.map((column, i) => {\n        if (column.columns) {\n          return {\n            ...column,\n            columns: column.columns.map(d => decorateAndAddToAll(d, column)),\n          }\n        } else {\n          return decorateAndAddToAll(column)\n        }\n      })\n\n      // Build the visible columns, headers and flat column list\n      let visibleColumns = decoratedColumns.slice()\n      let allVisibleColumns = []\n\n      visibleColumns = visibleColumns.map((column, i) => {\n        if (column.columns) {\n          const visibleSubColumns = column.columns.filter(\n            d =>\n              pivotBy.indexOf(d.id) > -1\n                ? false\n                : _.getFirstDefined(d.show, true)\n          )\n          return {\n            ...column,\n            columns: visibleSubColumns,\n          }\n        }\n        return column\n      })\n\n      visibleColumns = visibleColumns.filter(column => {\n        return column.columns\n          ? column.columns.length\n          : pivotBy.indexOf(column.id) > -1\n            ? false\n            : _.getFirstDefined(column.show, true)\n      })\n\n      // Find any custom pivot location\n      const pivotIndex = visibleColumns.findIndex(col => col.pivot)\n\n      // Handle Pivot Columns\n      if (pivotBy.length) {\n        // Retrieve the pivot columns in the correct pivot order\n        const pivotColumns = []\n        pivotBy.forEach(pivotID => {\n          const found = allDecoratedColumns.find(d => d.id === pivotID)\n          if (found) {\n            pivotColumns.push(found)\n          }\n        })\n\n        let PivotParentColumn = pivotColumns.reduce(\n          (prev, current) =>\n            prev && prev === current.parentColumn && current.parentColumn,\n          pivotColumns[0].parentColumn\n        )\n\n        let PivotGroupHeader = hasHeaderGroups && PivotParentColumn.Header\n        PivotGroupHeader = PivotGroupHeader || (() => <strong>Pivoted</strong>)\n\n        let pivotColumnGroup = {\n          Header: PivotGroupHeader,\n          columns: pivotColumns.map(col => ({\n            ...this.props.pivotDefaults,\n            ...col,\n            pivoted: true,\n          })),\n        }\n\n        // Place the pivotColumns back into the visibleColumns\n        if (pivotIndex >= 0) {\n          pivotColumnGroup = {\n            ...visibleColumns[pivotIndex],\n            ...pivotColumnGroup,\n          }\n          visibleColumns.splice(pivotIndex, 1, pivotColumnGroup)\n        } else {\n          visibleColumns.unshift(pivotColumnGroup)\n        }\n      }\n\n      // Build Header Groups\n      const headerGroups = []\n      let currentSpan = []\n\n      // A convenience function to add a header and reset the currentSpan\n      const addHeader = (columns, column) => {\n        headerGroups.push({\n          ...this.props.column,\n          ...column,\n          columns: columns,\n        })\n        currentSpan = []\n      }\n\n      // Build flast list of allVisibleColumns and HeaderGroups\n      visibleColumns.forEach((column, i) => {\n        if (column.columns) {\n          allVisibleColumns = allVisibleColumns.concat(column.columns)\n          if (currentSpan.length > 0) {\n            addHeader(currentSpan)\n          }\n          addHeader(column.columns, column)\n          return\n        }\n        allVisibleColumns.push(column)\n        currentSpan.push(column)\n      })\n      if (hasHeaderGroups && currentSpan.length > 0) {\n        addHeader(currentSpan)\n      }\n\n      // Access the data\n      const accessRow = (d, i, level = 0) => {\n        const row = {\n          [originalKey]: d,\n          [indexKey]: i,\n          [subRowsKey]: d[subRowsKey],\n          [nestingLevelKey]: level,\n        }\n        allDecoratedColumns.forEach(column => {\n          if (column.expander) return\n          row[column.id] = column.accessor(d)\n        })\n        if (row[subRowsKey]) {\n          row[subRowsKey] = row[subRowsKey].map((d, i) =>\n            accessRow(d, i, level + 1)\n          )\n        }\n        return row\n      }\n      let resolvedData = data.map((d, i) => accessRow(d, i))\n\n      // If pivoting, recursively group the data\n      const aggregate = rows => {\n        const aggregationValues = {}\n        aggregatingColumns.forEach(column => {\n          const values = rows.map(d => d[column.id])\n          aggregationValues[column.id] = column.aggregate(values, rows)\n        })\n        return aggregationValues\n      }\n\n      // TODO: Make it possible to fabricate nested rows without pivoting\n      const aggregatingColumns = allVisibleColumns.filter(\n        d => !d.expander && d.aggregate\n      )\n      if (pivotBy.length) {\n        const groupRecursively = (rows, keys, i = 0) => {\n          // This is the last level, just return the rows\n          if (i === keys.length) {\n            return rows\n          }\n          // Group the rows together for this level\n          let groupedRows = Object.entries(\n            _.groupBy(rows, keys[i])\n          ).map(([key, value]) => {\n            return {\n              [pivotIDKey]: keys[i],\n              [pivotValKey]: key,\n              [keys[i]]: key,\n              [subRowsKey]: value,\n              [nestingLevelKey]: i,\n              [groupedByPivotKey]: true,\n            }\n          })\n          // Recurse into the subRows\n          groupedRows = groupedRows.map(rowGroup => {\n            let subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1)\n            return {\n              ...rowGroup,\n              [subRowsKey]: subRows,\n              [aggregatedKey]: true,\n              ...aggregate(subRows),\n            }\n          })\n          return groupedRows\n        }\n        resolvedData = groupRecursively(resolvedData, pivotBy)\n      }\n\n      return {\n        ...newState,\n        resolvedData,\n        allVisibleColumns,\n        headerGroups,\n        allDecoratedColumns,\n        hasHeaderGroups,\n      }\n    }\n\n    getSortedData (resolvedState) {\n      const {\n        manual,\n        sorted,\n        filtered,\n        defaultFilterMethod,\n        resolvedData,\n        allVisibleColumns,\n        allDecoratedColumns,\n      } = resolvedState\n\n      const sortMethodsByColumnID = {}\n\n      allDecoratedColumns.filter(col => col.sortMethod).forEach(col => {\n        sortMethodsByColumnID[col.id] = col.sortMethod\n      })\n\n      // Resolve the data from either manual data or sorted data\n      return {\n        sortedData: manual\n          ? resolvedData\n          : this.sortData(\n            this.filterData(\n              resolvedData,\n              filtered,\n              defaultFilterMethod,\n              allVisibleColumns\n            ),\n            sorted,\n            sortMethodsByColumnID\n          ),\n      }\n    }\n\n    fireFetchData () {\n      this.props.onFetchData(this.getResolvedState(), this)\n    }\n\n    getPropOrState (key) {\n      return _.getFirstDefined(this.props[key], this.state[key])\n    }\n\n    getStateOrProp (key) {\n      return _.getFirstDefined(this.state[key], this.props[key])\n    }\n\n    filterData (data, filtered, defaultFilterMethod, allVisibleColumns) {\n      let filteredData = data\n\n      if (filtered.length) {\n        filteredData = filtered.reduce((filteredSoFar, nextFilter) => {\n          const column = allVisibleColumns.find(x => x.id === nextFilter.id)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          const filterMethod = column.filterMethod || defaultFilterMethod\n\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\n          if (column.filterAll) {\n            return filterMethod(nextFilter, filteredSoFar, column)\n          } else {\n            return filteredSoFar.filter(row => {\n              return filterMethod(nextFilter, row, column)\n            })\n          }\n        }, filteredData)\n\n        // Apply the filter to the subrows if we are pivoting, and then\n        // filter any rows without subcolumns because it would be strange to show\n        filteredData = filteredData\n          .map(row => {\n            if (!row[this.props.subRowsKey]) {\n              return row\n            }\n            return {\n              ...row,\n              [this.props.subRowsKey]: this.filterData(\n                row[this.props.subRowsKey],\n                filtered,\n                defaultFilterMethod,\n                allVisibleColumns\n              ),\n            }\n          })\n          .filter(row => {\n            if (!row[this.props.subRowsKey]) {\n              return true\n            }\n            return row[this.props.subRowsKey].length > 0\n          })\n      }\n\n      return filteredData\n    }\n\n    sortData (data, sorted, sortMethodsByColumnID = {}) {\n      if (!sorted.length) {\n        return data\n      }\n\n      const sortedData = (this.props.orderByMethod || _.orderBy)(\n        data,\n        sorted.map(sort => {\n          // Support custom sorting methods for each column\n          if (sortMethodsByColumnID[sort.id]) {\n            return (a, b) => {\n              return sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc)\n            }\n          }\n          return (a, b) => {\n            return this.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc)\n          }\n        }),\n        sorted.map(d => !d.desc),\n        this.props.indexKey\n      )\n\n      sortedData.forEach(row => {\n        if (!row[this.props.subRowsKey]) {\n          return\n        }\n        row[this.props.subRowsKey] = this.sortData(\n          row[this.props.subRowsKey],\n          sorted,\n          sortMethodsByColumnID\n        )\n      })\n\n      return sortedData\n    }\n\n    getMinRows () {\n      return _.getFirstDefined(\n        this.props.minRows,\n        this.getStateOrProp('pageSize')\n      )\n    }\n\n    // User actions\n    onPageChange (page) {\n      const { onPageChange, collapseOnPageChange } = this.props\n\n      const newState = { page }\n      if (collapseOnPageChange) {\n        newState.expanded = {}\n      }\n      this.setStateWithData(newState, () => {\n        onPageChange && onPageChange(page)\n      })\n    }\n\n    onPageSizeChange (newPageSize) {\n      const { onPageSizeChange } = this.props\n      const { pageSize, page } = this.getResolvedState()\n\n      // Normalize the page to display\n      const currentRow = pageSize * page\n      const newPage = Math.floor(currentRow / newPageSize)\n\n      this.setStateWithData(\n        {\n          pageSize: newPageSize,\n          page: newPage,\n        },\n        () => {\n          onPageSizeChange && onPageSizeChange(newPageSize, newPage)\n        }\n      )\n    }\n\n    sortColumn (column, additive) {\n      const { sorted, skipNextSort, defaultSortDesc } = this.getResolvedState()\n\n      const firstSortDirection = column.hasOwnProperty('defaultSortDesc')\n        ? column.defaultSortDesc\n        : defaultSortDesc\n      const secondSortDirection = !firstSortDirection\n\n      // we can't stop event propagation from the column resize move handlers\n      // attached to the document because of react's synthetic events\n      // so we have to prevent the sort function from actually sorting\n      // if we click on the column resize element within a header.\n      if (skipNextSort) {\n        this.setStateWithData({\n          skipNextSort: false,\n        })\n        return\n      }\n\n      const { onSortedChange } = this.props\n\n      let newSorted = _.clone(sorted || []).map(d => {\n        d.desc = _.isSortingDesc(d)\n        return d\n      })\n      if (!_.isArray(column)) {\n        // Single-Sort\n        const existingIndex = newSorted.findIndex(d => d.id === column.id)\n        if (existingIndex > -1) {\n          const existing = newSorted[existingIndex]\n          if (existing.desc === secondSortDirection) {\n            if (additive) {\n              newSorted.splice(existingIndex, 1)\n            } else {\n              existing.desc = firstSortDirection\n              newSorted = [existing]\n            }\n          } else {\n            existing.desc = secondSortDirection\n            if (!additive) {\n              newSorted = [existing]\n            }\n          }\n        } else {\n          if (additive) {\n            newSorted.push({\n              id: column.id,\n              desc: firstSortDirection,\n            })\n          } else {\n            newSorted = [\n              {\n                id: column.id,\n                desc: firstSortDirection,\n              },\n            ]\n          }\n        }\n      } else {\n        // Multi-Sort\n        const existingIndex = newSorted.findIndex(d => d.id === column[0].id)\n        // Existing Sorted Column\n        if (existingIndex > -1) {\n          const existing = newSorted[existingIndex]\n          if (existing.desc === secondSortDirection) {\n            if (additive) {\n              newSorted.splice(existingIndex, column.length)\n            } else {\n              column.forEach((d, i) => {\n                newSorted[existingIndex + i].desc = firstSortDirection\n              })\n            }\n          } else {\n            column.forEach((d, i) => {\n              newSorted[existingIndex + i].desc = secondSortDirection\n            })\n          }\n          if (!additive) {\n            newSorted = newSorted.slice(existingIndex, column.length)\n          }\n        } else {\n          // New Sort Column\n          if (additive) {\n            newSorted = newSorted.concat(\n              column.map(d => ({\n                id: d.id,\n                desc: firstSortDirection,\n              }))\n            )\n          } else {\n            newSorted = column.map(d => ({\n              id: d.id,\n              desc: firstSortDirection,\n            }))\n          }\n        }\n      }\n\n      this.setStateWithData(\n        {\n          page:\n            (!sorted.length && newSorted.length) || !additive\n              ? 0\n              : this.state.page,\n          sorted: newSorted,\n        },\n        () => {\n          onSortedChange && onSortedChange(newSorted, column, additive)\n        }\n      )\n    }\n\n    filterColumn (column, value) {\n      const { filtered } = this.getResolvedState()\n      const { onFilteredChange } = this.props\n\n      // Remove old filter first if it exists\n      const newFiltering = (filtered || []).filter(x => {\n        if (x.id !== column.id) {\n          return true\n        }\n      })\n\n      if (value !== '') {\n        newFiltering.push({\n          id: column.id,\n          value: value,\n        })\n      }\n\n      this.setStateWithData(\n        {\n          filtered: newFiltering,\n        },\n        () => {\n          onFilteredChange && onFilteredChange(newFiltering, column, value)\n        }\n      )\n    }\n\n    resizeColumnStart (event, column, isTouch) {\n      event.stopPropagation()\n      const parentWidth = event.target.parentElement.getBoundingClientRect()\n        .width\n\n      let pageX\n      if (isTouch) {\n        pageX = event.changedTouches[0].pageX\n      } else {\n        pageX = event.pageX\n      }\n\n      this.trapEvents = true\n      this.setStateWithData(\n        {\n          currentlyResizing: {\n            id: column.id,\n            startX: pageX,\n            parentWidth: parentWidth,\n          },\n        },\n        () => {\n          if (isTouch) {\n            document.addEventListener('touchmove', this.resizeColumnMoving)\n            document.addEventListener('touchcancel', this.resizeColumnEnd)\n            document.addEventListener('touchend', this.resizeColumnEnd)\n          } else {\n            document.addEventListener('mousemove', this.resizeColumnMoving)\n            document.addEventListener('mouseup', this.resizeColumnEnd)\n            document.addEventListener('mouseleave', this.resizeColumnEnd)\n          }\n        }\n      )\n    }\n\n    resizeColumnMoving (event) {\n      event.stopPropagation()\n      const { onResizedChange } = this.props\n      const { resized, currentlyResizing } = this.getResolvedState()\n\n      // Delete old value\n      const newResized = resized.filter(x => x.id !== currentlyResizing.id)\n\n      let pageX\n\n      if (event.type === 'touchmove') {\n        pageX = event.changedTouches[0].pageX\n      } else if (event.type === 'mousemove') {\n        pageX = event.pageX\n      }\n\n      // Set the min size to 10 to account for margin and border or else the group headers don't line up correctly\n      const newWidth = Math.max(\n        currentlyResizing.parentWidth + pageX - currentlyResizing.startX,\n        11\n      )\n\n      newResized.push({\n        id: currentlyResizing.id,\n        value: newWidth,\n      })\n\n      this.setStateWithData(\n        {\n          resized: newResized,\n        },\n        () => {\n          onResizedChange && onResizedChange(newResized, event)\n        }\n      )\n    }\n\n    resizeColumnEnd (event) {\n      event.stopPropagation()\n      let isTouch = event.type === 'touchend' || event.type === 'touchcancel'\n\n      if (isTouch) {\n        document.removeEventListener('touchmove', this.resizeColumnMoving)\n        document.removeEventListener('touchcancel', this.resizeColumnEnd)\n        document.removeEventListener('touchend', this.resizeColumnEnd)\n      }\n\n      // If its a touch event clear the mouse one's as well because sometimes\n      // the mouseDown event gets called as well, but the mouseUp event doesn't\n      document.removeEventListener('mousemove', this.resizeColumnMoving)\n      document.removeEventListener('mouseup', this.resizeColumnEnd)\n      document.removeEventListener('mouseleave', this.resizeColumnEnd)\n\n      // The touch events don't propagate up to the sorting's onMouseDown event so\n      // no need to prevent it from happening or else the first click after a touch\n      // event resize will not sort the column.\n      if (!isTouch) {\n        this.setStateWithData({\n          skipNextSort: true,\n          currentlyResizing: false,\n        })\n      }\n    }\n  }\n"]},"metadata":{},"sourceType":"script"}